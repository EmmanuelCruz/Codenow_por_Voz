module.exports = [
    {
        dato: "La sintaxis es la gramática que corresponde a un idioma. Esto se refiere a la forma de expresiones bien construidas.",
        tipo: "Sintaxis",
        res : "Gramática que corresponde a un lenguaje o idioma"
    },
    {
        dato: "La semántica se refiere al significado de cualquier tipo de expresiones bien construidas.",
        tipo: "Semántica",
        res : "Significado de una expresión bien construida"
    },
    {
        dato: "Un tipo es un nombre que representa un conjunto de valores. \nEn Java hay dos categorías de tipos: tipos primitivos y tipos de referencia. Los tipos de referencia también se conocen como compuestos.",
        tipo: "Tipos",
        res : "Nombre que representa un conjunto de valores"
    },
    {
        dato: "Los tipos primitivos son los tipos básicos que son directamente compatibles con el procesador de una computadora típica.",
        tipo: "Tipos primitivos",
        res: "Tipos básicos compatibles con el procesador de la computadora"
    },
    {
        dato: "boolean es un tipo primitivo que solo tiene dos valores: verdadero y falso.",
        tipo: "boolean",
        res: "Tipo que solo cuenta con los valores verdadero y falso"
    },
    {
        dato: "byte es un tipo primitivo. Enteros de 8 bits con un rango de valores de -128 a 127.",
        tipo: "byte",
        res: "Enteros de 8 bits de valores de -128 a 127"
    },{
        dato: "short es un tipo primitivo. Enteros de 16 bits con un rango de valores entre -32768 y 32767.",
        tipo: "short",
        res: "Enteros de 16 bits con valores entre -32768 y 32767"
    },{
        dato: "int es un tipo primitivo. Enteros de 32 bits con rango de valores entre -2147483648 y 2147483647",
        tipo: "int",
        res: "Enteros de 32 bits con valores entre -2147483648 y 2147483647"
    },
    {
        dato: "long es un tipo primitivo. Enteros de 64 bits con un rango de valores entre -9223372036854775808 y 9223372036854775807.",
        tipo: "long",
        res: "Valores entre -9223372036854775808 y 9223372036854775807"
    },
    {
        dato: "char es un tipo primitivo. Valores sin signo de 16 bits, de 0 a 65535, que representan caracteres Unicode.",
        tipo: "char",
        res: "Valores de 16 bits que representan caracteres Unicode"
    },
    {
        dato: "double es un tipo primitivo. Valores de punto flotante de precisión doble, con un rango de valores entre 4.9406564581246544e-324 y 1.79769313486231570e + 308",
        tipo: "double",
        res: "Valores de precisión doble"
    },
    {
        dato: "Una variable es un identificador que almacena un valor. Se dice que las variables describen el estado de un objeto.",
        tipo: "Variable",
        res: "Identificador que almacena un valor"
    },
    {
        dato: "Los operadores nos permiten realizar una acción u operación con ciertos parámetros. Los operadores de mayor precedencia dentro de una expresión siempre se aplican primero.",
        tipo: "Operadores",
        res: "Permiten realizar una acción con ciertos parámetros"
    },
    {
        dato: "Java tiene cinco operadores aritméticos: suma, resta, división, multiplicación, módulo o residuo.",
        tipo: "Operadores Aritméticos",
        res: "Suma, resta, división, multiplicación, módulo o residuo"
    },
    {
        dato: "El operador de concatenación permite concatenar dos elementos de tipo String. Es importante mencionar que si solo uno de los operandos es de tipo String, el otro operando se convierte en tipo String.",
        tipo: "Operador de concatenación",
        res: "Concatena dos elementos de tipo String"
    },
    {
        dato: "Los operadpres relacionales dan como resultado un valor booleano, depende de si la relación que representan se cumple o no. Igual a, distinto a, menor que, mayor que, mayor o igual que, menor o igual que.",
        tipo: "Operadores relacionales",
        res: "Valor booleano, dependiente de si una relación se cumple o no"
    },
    {
        dato: "Los tres operadores lógicos que devuelven un booleano están a continuación: AND, OR, NOT",
        tipo: "Operadores lógicos",
        res: "AND, OR, NOT. Regresan un valor booleano"
    },
    {
        dato: "Los operadores de asignación son operadores binarios, necesitan una variable y un valor del tipo de variable para asignar. Estos operadores asignan un valor a una variable",
        tipo: "Operadores de asignación",
        res: "Permiten asignar un valor a una variable"
    },
    {
        dato: "Una clase es una especificación genérica para un número arbitrario de objetos similares. Las clases permiten construir una taxonomía de un nivel abstracto. Si dos objetos presentan el mismo comportamiento, decimos que pertenecen a la misma clase.",
        tipo: "Clases",
        res: "Especificación genérica de un objeto: características y acciones"
    },
    {
        dato: "Tenemos tres modificadores de acceso: public, hace que una declaración sea accesible por cualquier clase; protected, hace una declaración accesible por cualquier subclase de la clase que se declara, o a cualquier clase dentro del mismo paquete; private, hace una declaración accesible sólo dentro de la clase en que se declara",
        tipo: "Modificadores de acceso",
        res: "public, private, protected"
    },
    {
        dato: "Un objeto es una instancia que corresponden a los ejemplares que podemos exhibir de una clase dada. Un mismo objeto puede pasar por distintos estados, esto depende del valor de los atributos que formen parte de un objeto.",
        tipo: "Objetos",
        res: "Instancia que corresponde al ejemplar de una clase"
    },
    {
        dato: "Las variables de instancia o atributos deben ser escogidos de tal forma que representen el estado de los objetos de una clase. Pueden ser de cualquier tipo, ya sea primitivo o de referencia. Por convención, una variable de instancia comienza con una letra minúscula.",
        tipo: "Atributos",
        res: "Variable que representa la característica de un objeto"
    },
    {
        dato: "Un atributo estático pertenece a una clase y no es única de una sola instancia. Una variable estática es una variable que es compartida por todas las instancias de una misma clase.",
        tipo: "Atributos estáticos",
        res: "Atributo cuyo valor comparten todos los ejemplares de una clase"
    },
    {
        dato: "Al definir un dato como constante o final le podremos asignar un valor por primera vez y luego de eso no será posible modificarlo. Una vez inicializado el dato, este no podrá cambiar su valor.",
        tipo: "Atributos constantes",
        res: "Atributos cuyo valor solo se define una vez y no se modifica"
    },
    {
        dato: "Un método es la especificación de una serie de acciones o de una acción propia de un objeto perteneciente a una clase. Las acciones que puede realizar un objeto debe estar definido en la Clase a la cual pertenezca el objeto.",
        tipo: "Métodos",
        res: "Especificación de una serie de acciones de un objeto de una clase"
    },
    {
        dato: "Un método constructor sirve para crear un nuevo objeto de un tipo específico. La declaración de un método constructor no tiene tipo de retorno, y su nombre debe coincidir con el nombre de la clase dentro de la cual es declarado. ",
        tipo: "Métodos constructores",
        res: "Crea un nuevo objeto a partir de las características de una clase"
    },
    {
        dato: "Los métodos de acceso sirven para proporcionar información respecto al estado del objeto. El nombre de estos métodos es get. Regresan un valor del tipo del atributo que deseamos observar. ",
        tipo: "Métodos de acceso",
        res: "Proporciona información del estado de un objeto"
    },
    {
        dato: "Los métodos mutantes se usan para modificar el estado del objeto. El nombre de estos métodos es set. El tipo de regreso es void. Además recibe un parámetro del tipo del atributo que se quiere modificar.",
        tipo: "Métodos mutantes",
        res: "Modifican el estado de un objeto"
    },
    {
        dato: "Los métodos auxiliares son métodos que sirven para resolver una subtarea. Es un auxiliar para resolver una parte de un problema general. El tipo de regreso y los parámetros que recibe dependen del servicio o problema que se quiera resolver. El tipo de acceso de estos métodos es privado. Representado con la palabra reservada private.",
        tipo: "Métodos auxiliares",
        res: "Método que resuelve una subtarea"
    },
    {
        dato: "Cuando una clase declara un método main, éste provee de un punto de inicio para la ejecución de un programa utilizando esa clase. Un método main toma un argumento de tipo arreglo de String, llamado args, y contiene cualquier argumento del comando de línea.",
        tipo: "Método main",
        res: "Método que da un punto de inicio a la ejecución de un programa"
    },
    {
        dato: "Controladores secuenciales. La ejecución prosigue, en orden, con cada línea, una después de la otra y siguiendo la organización física. Las tareas se ejecutarán exactamente en el orden que están listadas.",
        tipo: "Controladores secuenciales",
        res: "Ejecución de instrucciones una a una"
    },
    {
        dato: "La iteración marca a un cierto conjunto de enunciados secuenciales e indica la manera en que se van a repetir. En Java hay tres formas de generar iteración. Usando las siguientes estructuras de control: while, do… while y for.",
        tipo: "Iteración",
        res: "Controlador que permite repetir cierto conjunto de enunciados"
    },
    {
        dato: "El ciclo while se utiliza para ejecutar repetidamente una secuencia de líneas de código, mientras la evaluación de una condición booleana se mantenga como verdadera (true).",
        tipo: "while",
        res: "Ejecuta repetidamente una secuencia de líneas de código"
    },
    {
        dato: "El ciclo do while permite que las líneas de código que encierra se ejecuten al menos una vez, antes de realizar la evaluación de la expresión booleana. Si tal evaluación resulta con un valor verdadero (true), entonces el ciclo se vuelve a repetir.",
        tipo: "do while",
        res: "Ejecuta cierto conjunto de instrucciones repetidamente al menos una vez"
    },
    {
        dato: "El ciclo for permite la repetición controlada de una secuencia de líneas de código. La repetición se controla mediante una serie de expresiones: inicio, condición y actualización",
        tipo: "for",
        res: "Ejecuta repetidamente una secuencia de líneas"
    },
    {
        dato: "El enunciado if permite una selección en tiempo de ejecución del programa acerca de qué líneas de código se ejecutan o se omiten de la ejecución. En el caso de que la evaluación de la expresión booleana sea verdadera (true), el código que sigue se ejecuta, y en caso contrario (que se evalúe como false), se omite.",
        tipo: "if",
        res: "Ejecuta o no cierto conjunto de instrucciones"
    },
    {
        dato: "El enunciado switch permite escoger una entre varias opciones de secuencias de código a ser ejecutado. Su funcionamiento se basa en considerar una expresión que se va secuencialmente comparando con cada valor constante propuesto (o case) como resultado de su evaluación.",
        tipo: "switch",
        res: "Permite elegir entre una de varias opciones de acciones secuenciales"
    },
    {
        dato: "El operador condicional es un operador ternario (toma tres argumentos). Esencialmente, se comporta como una versión comprimida del enunciado if, y permite la elección en la evaluación de dos expresiones.",
        tipo: "Operador condicional",
        res: "Operador terminario que se comporta como un if else"
    },
    {
        dato: "La clase String representa cadenas de caracteres. Todos los literales de cadena en los programas Java, como abc, se implementan como instancias de esta clase.",
        tipo: "String",
        res: "Clase que representa cadenas de caracteres"
    },
    {
        dato: "Un escaner divide su entrada en tokens utilizando un patrón delimitador, que por defecto coincide con los espacios en blanco. Los tokens resultantes se pueden convertir en valores de diferentes tipos utilizando los siguientes métodos: nextInt, nextDouble, nextLine, entre otros",
        tipo: "Scanner",
        res: "Objeto que permite la entrada o salida de datos en un programa"
    },
    {
        dato: "Los arreglos son un acercamiento a los datos estructurados. Esto es, una estructura que puede almacenar información, en este caso, la abstracción se representa en objetos. Por lo que un arreglo es una estructura que puede almacenar elementos del mismo tipo. Los arreglos son contenedores de objetos y pueden almacenar un número fijo de elementos (o valores) que se pueden acceder mediante el indexado del propio arreglo. Los corchetes se utilizan para denotar arreglos.",
        tipo: "Arreglos",
        res: "Estructura lineal, homogénea, estática y de acceso directo"
    },
    {
        dato: "La herencia conlleva a la capacidad de reutilizar código de manera inteligente. La clase original se conoce como superclase con respecto a la nueva; decimos que la subclase hereda los atributos y métodos de la superclase.",
        tipo: "Herencia",
        res: "Capacidad de reutilizar código de manera inteligente"
    },
    {
        dato: "extends es una palabra reservada que sirve para especificar que una clase extiende a otra se hace con la palabra reservada extends en el encabezado de la clase.",
        tipo: "Extends",
        res: "Especifica que una clase extiende a otra"
    },
    {
        dato: "Una clase abstracta (abstract class) es un contenedor para declarar métodos y variables compartidos para usarse por subclases y para declarar una interfaz común de métodos y variables accesibles. Una clase declarada como abstract puede incluir cualquier variable estándar y declaración de métodos, pero no puede ser usada en una expresión.",
        tipo: "Clases abstractas",
        res: "Clase que puede o no contener métodos abstractos"
    },
    {
        dato: "La declaración de interfaces permite la especificación de un tipo de referencia sin proveer una implementación en la forma en que una clase lo hace. Esto provee de un mecanismo para declarar tipos que son distintos de las clases, lo que da una extensión importante a la forma en que los objetos y la herencia se usan en Java.",
        tipo: "Interfaces",
        res: "Especifica un conjunto de métodos abstractos"
    },
    {
        dato: "La palabra polimorfismo está formada con raíces griegas. Sus componentes léxicos son: polys que significa muchos, morfo que significa forma, más el sufijo -ismo que significa actividad o sistema. Dicho lo anterior, polimorfismo quiere decir cualidad de tener muchas formas.",
        tipo: "Polimorfismo",
        res: "Cualidad de tener muchas formas"
    },
    {
        dato: "La recursión, es una manera de especificar cosas basándose en su propia definición. Es una función que está definida en términos de sí misma. Es decir, usa su propia definición para definirse.",
        tipo: "Recursión",
        res: "Recursión es recursión"
    },
    {
        dato: "Una excepción es un mecanismo muy poderoso que tiene Java para detectar errores de ejecución de todo tipo. También se puede ver como un evento excepcional que ocurre cuando hay una falla en la ejecución de un programa o hay un error.",
        tipo: "Excepciones",
        res: "Mecanismo para detectar errores de ejecución"
    },
    {
        dato: "IllegalArgumentException es una excepción que es lanzada cuando métodos de Java o definidos por el usuario detecta que un argumento no es como se esperaba. Por ejemplo, si se desea sacar la raíz cuadrada de un número negativo.",
        tipo: "IllegalArgumentException",
        res: "Excepción que ocurre cuando un argumento no es como se esperaba"
    },
    {
        dato: "IndexOutOfBoundsException es una excepción que es lanzada cuando se intenta usar un elemento de un arreglo que no existe, porque el índice dado no está en el rango dado para los índices del arreglo.",
        tipo: "IndexOutOfBoundsException",
        res: "Excepción que ocurre se accede a un índice inválido"
    },
    {
        dato: "NullPointerException es una excepción que se lanza si se trata de usar al objeto referido por una referencia nula.",
        tipo: "NullPointerException",
        res: "Excepción que ocurre si se accede a información de un objeto null"
    },
];